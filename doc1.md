

### 寻址方式指令
内存地址引用的通用格式如下：
```
地址或者偏移(%基址寄存器,%索引寄存器,比例因子)
```
所有字段都可以选，计算地址的公式
```
结果地址 = 地址或者偏移 + %基址或偏移量寄存器 + 比例因子 * %索引寄存器
```
地址或者偏移以及比例因子都必须是常量，其余两个必须是寄存器。如果省略任何一项，那么等式中将以0代替该项

除了立即模式，所有其他寻址方式都可以用这种形式表示。

#### 直接寻址方式
此模式通过使用地址或偏移部分实现，
```
# 该指令将内存地址 ADDRESS加载到 %eax
movl ADDRESS, %eax
```

#### 索引寻址方式
此模式通过使用地址或偏移以及%索引寄存器部分实现。你可以将任何通用寄存器用作索引寄存器，也可以将索引寄存器的比例因子值常量定为 1,2,4，使之更适合为字节、双字节和字进行索引
```
# 该指令从string_start处开始，将该地址与 1*%ecx相加，并将所得值加载到%eax中
movl string_start(,%ecx,1), %eax
```

#### 间接寻址方式
间接寻址方式从寄存器指定的地址加载值
```
# 如下指令将 %eax中保存的地址中的值 移入 %ebx
movl (%eax), %ebx
```

#### 基址寻址方式
基址寻址方式与间接寻址方式类似，不同之处在于它将一个常量与寄存器中的地址相加
```
# 如下指令将 %eax 中保存的地址后4字节处 存储的值提取到 %ebx
movl 4(%eax), %ebx
```

#### 立即寻址方式
立即寻址方式非常简单。该方式会将直接值加载到寄存器或者存储位置
```
# 将数字12加载到%eax
movl $12, %eax
```

#### 寄存器寻址方式
寄存器寻址方式仅仅是将数据移入或者移出寄存器

### 移动的数值大小
%eax为例子，如果你一次只想用两个字节，那么可以只使用 %ax
%ax是%eax寄存器最低有效字（即数值的后半部分），适合用于处理两个字节的数值
%ax可以进一步分成%al和%ah。
%al是%ax寄存器的最低有效半字，%ah是最高有效半字。

#### movl相关命令， movl,movw,movb
其中 x 可以是下面的字符：
    1，l用于32位的长字值
    2，w用于16位的字值
    3，b用于8位的字节值

## 4 关于函数

### 4.1 处理复度

使用函数将程序划分为可独立开发和测试的各部分。函数是在指定类型的数据上完成所定义的某个工作的代码段。


### 4.2 函数的工作原理

#### 函数名
函数名是一个符号，代表该杉树代码的起始地址。在汇编语言中，符号是通过在函数代码前输入函数名作为标签来定义的，就像之前用于跳转的标签

#### 函数参数
函数参数是显示给函数以进行处理的数据项。某些参数有很多参数，有些不含参数

#### 局部变量
局部变量是函数在进行处理时使用的数据存储区，在函数返回时即被废弃。对于局部变量，程序中的任何其他函数都无法访问

#### 静态变量
静态变量也是函数进行处理时用到的数据存储区，但使用后不会被废弃。每当函数代码被激活时都重复使用。
程序的任何其他部分都无法访问此数据。除非绝对必要，否则我们一般不实用静态变量，因为他们可能在将来引起各种问题

#### 全局变量
全局变量是函数进行处理时用到的，在函数之外管理的数据存储区。

#### 返回地址
返回地址是一个“看不见”的参数，因为它不能直接在函数中使用。返回地址这一桉树高速函数当其执行完毕后应该再从哪里开始执行。
在大多数编程语言中，调用函数时候会自动传递这个参数。
而在汇编语言中，call指令会为你处理返回地址，ret指令则负责按照该地址返回到函数调用的地方

#### 返回值
返回值是传回数据到主程序的主要方法。大多数编程语言只允许一个函数有一个返回值。

#### 总结
以上这些部分在大多数编程语言中都存在。然而在每种语言中如何指定每一项却各不相同。
在不同的语言中，变量存储以及计算机传输参数和返回值的方式各不相同。这种差异成为语言的调用约定，因为它描述了在调用函数时，函数预期得到什么样的数据。

汇编语言能使用其偏好的任何调用约定，你甚至可以自己定一个调用约定。但是如果你想与其他语言编写的函数进行互动，就必须服从其他语言的调用约定。


### 4.3 使用C调用约定的汇编语言函数

pushl 指令将一个寄存器值或内存值压入栈顶（栈顶实际上是栈内存的底部，栈内存从高地址向低地址扩展）。
popl 指令将值从栈顶弹出。该指令将值从栈顶移除，并把其放入寄存器或你选择的存储位置

当我们将值入栈的时候，栈顶会移动，以容纳新增加的值。

栈寄存器%esp正品美国时间哦哪怕就啊吗讴歌指向当前栈顶的指针，无论栈顶在何处。
每当我们用pushl将数据入栈，%esp所含的指针值都会减去4，从而指向新的栈顶
popl指令则从栈中删除数据，并且该指令使%esp的值增加4，并将先前的栈顶的值放入你指定的寄存器
pushl和popl都有一个操作数。
对于pushl，是要将其值入栈的寄存器；对于popl，是要接受弹出栈数据的寄存器

如果我们只是想访问栈顶的值，而不像移除该值，在简介寻址方式中使用 %esp即可

```
# 以下代码将栈顶的内容移入 %eax
movl (%esp), %eax

# 以下代码将会在%eax中保存栈顶的指针, 而不是栈顶存放的值。
movl %esp, $eax

# 如果想访问栈顶的下一个值，我们只需要发出指令 (这条指令使用基地址寻址方式，在寻找指针指向的值之前将%esp与4相加)
movl 4(%esp), %eax
```

在C语言的调用约定中，栈是实现函数的局部变量、参数和返回地址的关键因素